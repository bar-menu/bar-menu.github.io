<!DOCTYPE html>
<html>
<head>
    <base target="_top">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Form Correzione</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        /* Stili Base e Tipografia (come li avevi definiti) */
        html { -webkit-text-size-adjust: 100%; text-size-adjust: 100%; box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; margin: 0; padding: 20px; background-color: var(--tg-theme-bg-color, #ffffff); color: var(--tg-theme-text-color, #000000); font-size: 17px; line-height: 1.6; }
        h2 { color: var(--tg-theme-text-color); border-bottom: 1px solid var(--tg-theme-hint-color); padding-bottom: 12px; margin-top: 0; margin-bottom: 25px; font-size: 1.4em; font-weight: 600; text-align: center; }
        label { display: block; margin-top: 20px; margin-bottom: 8px; font-weight: 500; font-size: 0.95em; color: var(--tg-theme-hint-color); }
        input[type="text"], input[type="date"], input[type="time"], textarea, select, div[contenteditable="true"].input { width: 100%; padding: 14px 12px; margin-top: 0; border: 1.5px solid var(--tg-theme-hint-color, #cccccc); border-radius: 10px; background-color: var(--tg-theme-secondary-bg-color, #f9f9f9); color: var(--tg-theme-text-color); box-sizing: border-box; font-size: 1em; transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; }
        select { padding: 14px 12px; appearance: none; -webkit-appearance: none; -moz-appearance: none; background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23007AFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E"); background-repeat: no-repeat; background-position: right 12px center; background-size: 12px auto; }
        input[readonly] { background-color: var(--tg-theme-secondary-bg-color, #eeeeee); opacity: 0.7; border-color: var(--tg-theme-hint-color, #dddddd); }
        input[type="text"]:focus, input[type="date"]:focus, input[type="time"]:focus, textarea:focus, select:focus, div[contenteditable="true"].input:focus { border-color: var(--tg-theme-button-color, #2481CC); box-shadow: 0 0 0 3px var(--tg-theme-button-color-alpha, rgba(36, 129, 204, 0.25)); outline: none; }
        :root { --tg-theme-button-color-alpha: rgba(36, 129, 204, 0.25); --tg-theme-destructive-text-color-alpha: rgba(255, 77, 77, 0.25); }
        input.input-error, select.input-error, div[contenteditable="true"].input.input-error { border-color: var(--tg-theme-destructive-text-color, #ff4d4d) !important; box-shadow: 0 0 0 3px var(--tg-theme-destructive-text-color-alpha, rgba(255, 77, 77, 0.25)) !important; }
        .error-message { font-size: 0.8em; color: var(--tg-theme-destructive-text-color, #ff4d4d); margin-top: 4px; min-height: 1.2em;}
        textarea { min-height: 100px; resize: vertical; }
        /* Stili per il div contenteditable per farlo assomigliare agli altri input */
        div[contenteditable="true"].input {
            min-height: 50px; /* Ridotta altezza minima, simile ad altri input */
            line-height: 1.6; 
            -webkit-user-modify: read-write-plaintext-only; 
            white-space: pre-wrap; 
            word-wrap: break-word; 
        }
        /* Placeholder per contenteditable */
        div[contenteditable="true"].input:empty::before {
            content: attr(data-placeholder);
            color: var(--tg-theme-hint-color, #999999);
            pointer-events: none; /* Permette il click "attraverso" il placeholder */
            display: block; /* Assicura che occupi spazio */
        }
        .info-summary { background-color: var(--tg-theme-secondary-bg-color, #f0f0f0); padding: 15px; border-radius: 10px; margin-bottom: 25px; border: 1px solid var(--tg-theme-hint-color, #e0e0e0); }
        .info-summary p { margin: 5px 0 10px 0; font-size: 1em; display: flex; align-items: baseline; }
        .info-summary .info-label { font-weight: 500; color: var(--tg-theme-hint-color); margin-right: 8px; font-size: 0.9em; flex-shrink: 0; }
        .info-summary .info-value { font-weight: 600; color: var(--tg-theme-text-color); }
        #summaryEmployeeName.info-value { text-transform: uppercase; padding: 2px 6px; border-radius: 4px; font-size: 0.95em; }
        .info-summary .problem-details-container { margin: 5px 0 10px 0; font-size: 1em; display: flex; align-items: flex-start; }
        .problem-value-multiline #problemType, .problem-value-multiline #problemTime, .problem-value-multiline #problemDateText { display: block; line-height: 1.4;}
        .problem-value-multiline #problemTime { font-weight: normal; }
        .problem-value-multiline #problemDateText { font-weight: 600; }
        .field-group { margin-bottom: 20px; }
        .date-info-text { font-size: 0.8em; color: var(--tg-theme-hint-color); margin-top: 4px; font-style: italic; }
        #missingTimeDateContext { font-size: 0.85em; color: var(--tg-theme-hint-color); margin-left: 8px; font-style: italic; min-height: 1.2em;}
        .modal-button { background-color: var(--tg-theme-button-color, #2481CC); color: var(--tg-theme-button-text-color, #FFFFFF); padding: 14px 18px; border: none; border-radius: 8px; cursor: pointer; font-size: 1em; font-weight: 500; transition: background-color 0.2s ease, opacity 0.2s ease, transform 0.1s ease; }
        .modal-button:hover:not(:disabled) { opacity: 0.85; }
        .modal-button:active:not(:disabled) { transform: scale(0.98); }
        #loadingMessage, #errorMessage { text-align: center; padding: 30px 20px; font-style: italic; font-size: 1em; color: var(--tg-theme-hint-color); }
        #errorMessage { color: var(--tg-theme-destructive-text-color, red); font-weight: bold; }
        #debugSection { margin-top: 30px; padding-top: 20px; border-top: 1px solid var(--tg-theme-hint-color); }
        #debugSection h3 { font-size: 1.1em; text-align: left; border-bottom: none; margin-bottom: 10px; }
        #debugSection p { font-size: 0.9em; margin: 5px 0; }
        #debugSection pre { background-color: var(--tg-theme-secondary-bg-color, #f0f0f0); padding: 10px; border: 1px solid var(--tg-theme-hint-color, #e0e0e0); border-radius: 6px; font-size: 0.85em; word-wrap: break-word; white-space: pre-wrap; }
    </style>
</head>
<body style="visibility: hidden;">
    <div id="formContainer" style="display: none;">
        <h2>Form Correzione</h2>
        <div class="info-summary">
            <p><span class="info-label">Dipendente:</span><strong id="summaryEmployeeName" class="info-value">N/D</strong></p>
            <div class="problem-details-container">
                <span class="info-label">Problema:</span>
                <div id="summaryProblemFullDescription" class="info-value problem-value-multiline">
                    <span id="problemType">N/D</span>
                    <span id="problemTime">N/D</span>
                    <span id="problemDateText">N/D</span>
                </div>
            </div>
        </div>
        <form id="correctionForm">
            <input type="hidden" id="problemContextIdInput" name="problemContextId">
            <input type="hidden" id="originalEmployeeNameInput" name="originalEmployeeName">
            <input type="hidden" id="originalProblemDateISOInput" name="originalProblemDateISO">
            <input type="hidden" id="originalSingleTimeInput" name="originalSingleTime">
            <input type="hidden" id="originalSingleBarInput" name="originalSingleBar">
            <!-- notesHiddenInput rimosso -->
            <input type="hidden" id="correctorUserIdInput" name="correctorUserId">
            <input type="hidden" id="correctorUserNameInput" name="correctorUserName">
            <input type="hidden" id="correctorUserFirstNameInput" name="correctorUserFirstName">
            <input type="hidden" id="correctorUserLastNameInput" name="correctorUserLastName">
            <input type="hidden" id="effectiveOriginalSolarDateISOInput" name="effectiveOriginalSolarDateISO">

            <div class="field-group" id="dateCorrectionGroup" style="display:none;">
                <label for="correctedDate">Data Corretta (lascia vuoto per deduzione):</label>
                <input type="date" id="correctedDate" name="correctedDate">
                <p class="date-info-text">La data verrà dedotta automaticamente se possibile.</p>
            </div>
            <div class="field-group" id="singleTimeCorrectionSection" style="display:none;">
                <label for="singleCorrectionAction">Aggiungere:</label>
                <select id="singleCorrectionAction" name="singleCorrectionAction">
                    <option value="">-- Seleziona un'azione --</option>
                    <option value="isEntry_addExit">Uscita Mancante</option>
                    <option value="isExit_addEntry">Entrata Mancante</option>
                </select>
                 <div id="singleCorrectionActionError" class="error-message" style="display:none;"></div>
            </div>
            <div class="field-group" id="missingTimeFieldGroup" style="display:none;">
                <div style="display: flex; align-items: center;">
                    <div style="flex-grow: 1;">
                        <label for="missingTimeValue" id="missingTimeLabel">Orario Mancante (HH:MM):</label>
                        <input type="time" id="missingTimeValue" name="missingTimeValue">
                        <div id="missingTimeError" class="error-message" style="display:none;"></div>
                    </div>
                    <span id="missingTimeDateContext"></span>
                </div>
            </div>
            <!-- Nuovo campo note -->
            <div class="field-group">
                <label for="text_field">Note:</label>
                <div
                    class="input" 
                    contenteditable="true"
                    data-placeholder="Aggiungi nota (opzionale)..."
                    id="text_field"
                ></div>
            </div>
        </form>
    </div>
    <!-- notesModalOverlay rimosso -->
    <div id="loadingMessage">Caricamento dati...</div>
    <div id="errorMessage" style="display:none;"></div>
    <div id="debugSection" style="display: none;"></div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const tg = window.Telegram.WebApp;
            const GAS_WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbzxAMul4wSZO6YVPGrsnhUJmqpUY2jDkgu2-qONZ27SjynWubJyJz_kZrUyBdNm4M9-OA/exec';

            const formContainer = document.getElementById('formContainer');
            const loadingMessage = document.getElementById('loadingMessage');
            const errorMessageDiv = document.getElementById('errorMessage');
            const summaryEmployeeName = document.getElementById('summaryEmployeeName');
            const problemTypeSpan = document.getElementById('problemType');
            const problemTimeSpan = document.getElementById('problemTime');
            const problemDateTextSpan = document.getElementById('problemDateText');
            
            const problemContextIdInput = document.getElementById('problemContextIdInput');
            const originalEmployeeNameInput = document.getElementById('originalEmployeeNameInput');
            const originalProblemDateISOInput = document.getElementById('originalProblemDateISOInput');
            const originalSingleTimeInput = document.getElementById('originalSingleTimeInput');
            const originalSingleBarInput = document.getElementById('originalSingleBarInput');
            // notesHiddenInput rimosso
            const correctorUserIdInput = document.getElementById('correctorUserIdInput'); 
            const correctorUserNameInput = document.getElementById('correctorUserNameInput');
            const correctorUserFirstNameInput = document.getElementById('correctorUserFirstNameInput');
            const correctorUserLastNameInput = document.getElementById('correctorUserLastNameInput');
            
            const correctedDateInput = document.getElementById('correctedDate');
            const singleCorrectionActionSelect = document.getElementById('singleCorrectionAction');
            const singleCorrectionActionError = document.getElementById('singleCorrectionActionError');
            const missingTimeValueInput = document.getElementById('missingTimeValue');
            const missingTimeLabel = document.getElementById('missingTimeLabel');
            const missingTimeDateContext = document.getElementById('missingTimeDateContext');
            const missingTimeError = document.getElementById('missingTimeError');
            
            const dateCorrectionGroup = document.getElementById('dateCorrectionGroup');
            const singleTimeCorrectionSection = document.getElementById('singleTimeCorrectionSection');
            const missingTimeFieldGroup = document.getElementById('missingTimeFieldGroup');
            
            // Elementi del vecchio sistema di note rimossi:
            // const addNotesButton = document.getElementById('addNotesButton');
            // const currentNotesDisplay = document.getElementById('currentNotesDisplay');
            // const notesModalOverlay = document.getElementById('notesModalOverlay');
            // const notesTextareaModal = document.getElementById('notesTextareaModal');
            // const saveNotesButton = document.getElementById('saveNotesButton');
            // const cancelNotesButton = document.getElementById('cancelNotesButton');
            const notesTextField = document.getElementById('text_field'); // Nuovo campo note

            const debugSection = document.getElementById('debugSection');

            let initialStartParamData = null;
            let currentUserDetails = { id: null, username: "", first_name: "", last_name: "" };
            let isDebugMode = false; 
            let startParamValueForDebug = "Nessuno (non letto)";

            function setThemeClass() { if (tg && tg.colorScheme) { document.documentElement.className = tg.colorScheme; } else { console.warn("setThemeClass: tg o tg.colorScheme non definiti.");} }
            function hexToRgba(hex, alpha) { if(!hex || typeof hex !== 'string') hex = '#000000'; hex=hex.replace('#',''); const r=parseInt(hex.substring(0,2),16)||0; const g=parseInt(hex.substring(2,4),16)||0; const b=parseInt(hex.substring(4,6),16)||0; return `rgba(${r},${g},${b},${alpha})`;}
            function applyThemeVariables() { const rootStyle=document.documentElement.style; if (!tg || !tg.themeParams) { console.warn("applyThemeVariables: tg o tg.themeParams non definiti."); return; } const buttonColor=tg.themeParams.button_color||'#2481CC'; const destructiveColor=tg.themeParams.destructive_text_color||'#ff4d4d'; rootStyle.setProperty('--tg-theme-button-color-alpha',hexToRgba(buttonColor,0.25)); rootStyle.setProperty('--tg-theme-destructive-text-color-alpha',hexToRgba(destructiveColor,0.25));}
            
            function showFatalError(message, startParamVal = "Non disponibile", parsedData = null, initData = null, initUnsafe = null, locSearch = null) {
                loadingMessage.style.display='none'; formContainer.style.display='none';
                errorMessageDiv.textContent="ERRORE AVVIO: " + message; errorMessageDiv.style.display='block';
                console.error("FATAL ERROR MiniApp:",message);
                if (tg && tg.MainButton) tg.MainButton.hide(); 
                if (debugSection) debugSection.style.display = 'block';
                updateDebugSection(startParamVal, parsedData, initData, initUnsafe, locSearch, "ERRORE FATALE: " + message);
                document.body.style.visibility = 'visible';
            }

            function base64UrlDecode(str) { if(!str||typeof str!=='string'||str.trim()==="")return null; try{let base64=str.replace(/-/g,'+').replace(/_/g,'/'); while(base64.length%4){base64+='=';} return decodeURIComponent(atob(base64).split('').map(function(c){return '%'+('00'+c.charCodeAt(0).toString(16)).slice(-2);}).join(''));}catch(e){console.error("Errore base64UrlDecode:",e,"Stringa:",str);return null;}}
            
            function parseStartParam(startParamString) {
                console.log("parseStartParam - Ricevuto:", startParamString);
                if(!startParamString||startParamString==="Nessuno"||startParamString.trim()===""){ console.error("parseStartParam: Parametro avvio mancante."); return{error:"Parametro di avrio mancante."};}
                const decodedJsonString=base64UrlDecode(startParamString);
                if(!decodedJsonString){ console.error("parseStartParam: Decodifica Base64 fallita.","Input:",startParamString); return{error:"Decodifica parametro fallita.",rawValue:startParamString};}
                try{ const parsed = JSON.parse(decodedJsonString); console.log("parseStartParam - Dati Parsati OK:", parsed); return parsed;}
                catch(e){console.error("parseStartParam: Errore Parsing JSON.","Errore:", e, "Stringa Decodificata:", decodedJsonString); return{error:"Formato dati non valido (JSON).",rawValue:startParamString,decodedValue:decodedJsonString};}
            }

            function updateDebugSection(startParamVal, parsedDataObj, initDataStr, initDataUnsafeObj, locationSearchStr, extraError = "") {
                if (!debugSection) return;
                let debugContent = `
                    <h3>Debug Dati Telegram Ricevuti:</h3>
                    <p><strong>Parametro Start (valore grezzo ricevuto):</strong></p><pre>${startParamVal === undefined ? "undefined" : (startParamVal === null ? "null" : String(startParamVal))}</pre>
                    <p><strong>Dati Parsati da Start Param (se JSON):</strong></p><pre>${parsedDataObj ? JSON.stringify(parsedDataObj, null, 2) : "N/D o errore parsing"}</pre>
                    <p><strong>initData (grezzo):</strong></p><pre>${initDataStr || "Non presente"}</pre>
                    <p><strong>initDataUnsafe (JSON):</strong></p><pre>${initDataUnsafeObj ? JSON.stringify(initDataUnsafeObj, null, 2) : "Non presente"}</pre>
                    <p><strong>URL Search (window.location.search):</strong></p><pre>${locationSearchStr || "Vuoto"}</pre>`;
                if (extraError) debugContent += `<p><strong>ERRORE AGGIUNTIVO:</strong></p><pre style="color:red;">${extraError}</pre>`;
                debugSection.innerHTML = debugContent;
            }
            
            function populateUI(data) {
                console.log("populateUI - Dati Input (abbreviati):", JSON.stringify(data));
                if (!data || data.error) {
                    const errorMsg = `Dati iniziali per il form non validi. ${data && data.error ? data.error : ''} ${data && data.rawValue ? `(Grezzo: ${data.rawValue.substring(0,30)}...)` : ''}`;
                    showFatalError(errorMsg, startParamValueForDebug, data, tg.initData, tg.initDataUnsafe, window.location.search);
                    return;
                }
                initialStartParamData = data;

                // Calcola la data solare effettiva della timbratura originale
                let calculatedEffectiveOriginalSolarDateISO = data.pDateISO; // Inizializza con il giorno lavorativo
                if (data.origTime && isValidTimeFormat(data.origTime)) { 
                    const [hOrig, mOrig] = data.origTime.split(':').map(Number);
                    if (hOrig < 5) { 
                        calculatedEffectiveOriginalSolarDateISO = G_addDaysToISONoTime(data.pDateISO, 1);
                    }
                }
                // Salva la data solare originale calcolata nell'input nascosto
                const effectiveOriginalSolarDateISOInput = document.getElementById('effectiveOriginalSolarDateISOInput');
                if (effectiveOriginalSolarDateISOInput) {
                    effectiveOriginalSolarDateISOInput.value = calculatedEffectiveOriginalSolarDateISO;
                    console.log("populateUI: Effective Original Solar Date calcolata e salvata:", calculatedEffectiveOriginalSolarDateISO);
                } else {
                    console.warn("populateUI: Input 'effectiveOriginalSolarDateISOInput' non trovato nell'HTML!");
                    // Considera un errore fatale se questo input è cruciale per la validazione
                }  

                // Popola il riepilogo in alto
                summaryEmployeeName.textContent = data.name || 'N/D'; 

                let mainProblemDescriptionUI = "Problema Rilevato"; 
                if (data.pType) { 
                    switch (data.pType.toUpperCase()) {
                        case 'SINGLE_TIMESTAMP': mainProblemDescriptionUI = "Timbratura singola"; break;
                        case 'TIME_05XX': mainProblemDescriptionUI = "Timbratura orario 05:xx"; break;
                        case 'DURATION_EXCEEDED_15H': mainProblemDescriptionUI = "Durata servizio > 15 ore"; break;
                        case 'DURATION_TOO_SHORT_1H': mainProblemDescriptionUI = "Durata servizio < 1 ora"; break;
                        case 'LOGICAL_ERROR_TIME': mainProblemDescriptionUI = "Errore logico (uscita < entrata)"; break;
                        default: mainProblemDescriptionUI = `Tipo Problema: ${data.pType}`; // Più generico
                    }
                }
                problemTypeSpan.textContent = mainProblemDescriptionUI;

                // --- VISUALIZZAZIONE MODIFICATA PER CHIAREZZA ---
                let timeAndBarDisplayForOriginal = '';
                let originalSolarDateFormattedForDisplay = 'N/D';

                if (data.origTime) { 
                    timeAndBarDisplayForOriginal = data.origTime;
                    if (data.origBar && data.origBar !== "N/D") { 
                        timeAndBarDisplayForOriginal += ` (Bar ${data.origBar})`;
                    }
                    // Usa la data solare effettiva calcolata per il display
                    if (calculatedEffectiveOriginalSolarDateISO) {
                        originalSolarDateFormattedForDisplay = formatDate_DDMMYYYY(calculatedEffectiveOriginalSolarDateISO);
                    }
                }
                
                // Mostra l'ora originale e la SUA DATA SOLARE
                if (problemTimeSpan) {
                    if (timeAndBarDisplayForOriginal) {
                        problemTimeSpan.textContent = `${timeAndBarDisplayForOriginal} del ${originalSolarDateFormattedForDisplay}`;
                    } else {
                        problemTimeSpan.textContent = "Dettaglio orario originale non disponibile.";
                    }
                }

                // Specifica che la data problema si riferisce al GIORNO LAVORATIVO
                let workDayDateFormattedForDisplay = 'N/D';
                if (data.pDateISO) { 
                    workDayDateFormattedForDisplay = formatDate_DDMMYYYY(data.pDateISO);
                }
                if (problemDateTextSpan) {
                    problemDateTextSpan.textContent = `(Giorno Lavorativo: ${workDayDateFormattedForDisplay})`;
                }
                // --- FINE VISUALIZZAZIONE MODIFICATA ---

                // Popola gli input nascosti del form
                problemContextIdInput.value = data.ctxId || ''; 
                originalEmployeeNameInput.value = data.name || '';
                originalProblemDateISOInput.value = data.pDateISO || ''; // Questo rimane il giorno LAVORATIVO
                originalSingleTimeInput.value = data.origTime || '';
                originalSingleBarInput.value = data.origBar || '';
                
                correctorUserIdInput.value = currentUserDetails.id || '';
                correctorUserNameInput.value = currentUserDetails.username || '';
                correctorUserFirstNameInput.value = currentUserDetails.first_name || '';
                correctorUserLastNameInput.value = currentUserDetails.last_name || '';

                // Popola il campo note (div contenteditable)
                if (notesTextField) {
                    if (data.notes && typeof data.notes === 'string') { // Verifica che data.notes esista e sia una stringa
                        notesTextField.textContent = data.notes.trim();
                    } else {
                        notesTextField.textContent = ''; // Assicura che sia vuoto per il placeholder CSS
                    }
                    // Se il contenuto è vuoto dopo averlo impostato, il placeholder CSS dovrebbe attivarsi
                    if (notesTextField.textContent.trim() === '') {
                         notesTextField.innerHTML = ''; // Forza il placeholder se era solo spazi bianchi
                    }
                }

                // Logica per mostrare/nascondere sezioni del form
                dateCorrectionGroup.style.display = 'none'; // Al momento sempre nascosto
                singleTimeCorrectionSection.style.display = 'none';
                missingTimeFieldGroup.style.display = 'none';
                if (missingTimeDateContext) { // Assicurati che esista
                    missingTimeDateContext.dataset.inferredMissingPairDate = ""; 
                }


                const isSingleTimestampProblem = data.pType && data.pType.toUpperCase() === 'SINGLE_TIMESTAMP';
                if (isSingleTimestampProblem) {
                    singleTimeCorrectionSection.style.display = 'block';
                    if (singleCorrectionActionSelect) singleCorrectionActionSelect.value = ''; 
                    handleSingleCorrectionActionChange(); // Questo mostrerà/nasconderà missingTimeFieldGroup e aggiornerà il contesto data
                }
                
                // Finalizza la UI
                loadingMessage.style.display = 'none';
                errorMessageDiv.style.display = 'none';
                formContainer.style.display = 'block';
                document.body.style.visibility = 'visible';
                updateDebugSection(startParamValueForDebug, initialStartParamData, tg.initData, tg.initDataUnsafe, window.location.search);
                updateMainButtonState(); 
            }
            function isValidTimeFormat(timeString) { return timeString && /^([01]\d|2[0-3]):([0-5]\d)$/.test(timeString); }
            function formatDate_DDMMYYYY(dateStrYYYYMMDD) { if (!dateStrYYYYMMDD || typeof dateStrYYYYMMDD !== 'string') return ""; const parts = dateStrYYYYMMDD.split('-'); if (parts.length !== 3) return dateStrYYYYMMDD; return `${parts[2]}-${parts[1]}-${parts[0]}`; }
            
            function G_addDaysToISONoTime(isoDateStringYYYYMMDD, days) {
                if (!isoDateStringYYYYMMDD) return "";
                try {
                    const [year, month, day] = isoDateStringYYYYMMDD.split('-').map(Number);
                    const date = new Date(Date.UTC(year, month - 1, day)); 
                    date.setUTCDate(date.getUTCDate() + days);
                    return date.toISOString().split('T')[0];
                } catch (e) {
                    console.error("Errore in G_addDaysToISONoTime:", e, "Input:", isoDateStringYYYYMMDD);
                    return isoDateStringYYYYMMDD; 
                }
            }


            function updateMissingTimeDateContext() {
                // Recupera gli elementi e i valori necessari
                const originalTimeStr = document.getElementById('originalSingleTimeInput').value;
                const effectiveAnchorSolarDateISO = document.getElementById('effectiveOriginalSolarDateISOInput').value;
                const newTimeValue = document.getElementById('missingTimeValue').value;
                const action = document.getElementById('singleCorrectionAction').value;
                const missingTimeDateContext = document.getElementById('missingTimeDateContext');

                // Pulisci lo stato precedente
                missingTimeDateContext.textContent = '';
                missingTimeDateContext.dataset.inferredMissingPairDate = '';

                // Se non abbiamo i dati base, non facciamo nulla.
                if (!isValidTimeFormat(newTimeValue) || !isValidTimeFormat(originalTimeStr) || !effectiveAnchorSolarDateISO) {
                    return;
                }

                try {
                    // 1. CREA LA DATA/ORA DELL'ANCORA, basata sulla sua data SOLARE effettiva.
                    const anchorDateTime = new Date(`${effectiveAnchorSolarDateISO}T${originalTimeStr}:00Z`);

                    // 2. CREA LA NUOVA DATA/ORA, partendo dalla data solare dell'ancora.
                    const [newH, newM] = newTimeValue.split(':').map(Number);
                    let newDateTime = new Date(`${effectiveAnchorSolarDateISO}T00:00:00Z`);
                    newDateTime.setUTCHours(newH, newM, 0, 0);

                    // 3. APPLICA LO SHIFT DEL GIORNO, se necessario.
                    let dayShift = 0;
                    if (action === 'isEntry_addExit' && newDateTime.getTime() <= anchorDateTime.getTime()) {
                        dayShift = 1; // Uscita è il giorno dopo
                    } else if (action === 'isExit_addEntry' && newDateTime.getTime() >= anchorDateTime.getTime()) {
                        dayShift = -1; // Entrata è il giorno prima
                    }

                    if (dayShift !== 0) {
                        newDateTime.setUTCDate(newDateTime.getUTCDate() + dayShift);
                    }
                    
                    // 4. AGGIORNA LA UI e i dati nascosti
                    const inferredDateISO = newDateTime.toISOString().split('T')[0];
                    missingTimeDateContext.dataset.inferredMissingPairDate = inferredDateISO;
                    missingTimeDateContext.textContent = `(del ${formatDate_DDMMYYYY(inferredDateISO)})`;

                } catch (e) {
                    console.error("Errore in updateMissingTimeDateContext:", e);
                    missingTimeDateContext.textContent = '(Errore Calcolo)';
                }
            }


            function handleSingleCorrectionActionChange() {
                const action = singleCorrectionActionSelect.value;
                if (!missingTimeLabel || !missingTimeFieldGroup || !missingTimeValueInput || !missingTimeError || !singleCorrectionActionSelect || !singleCorrectionActionError) return;
                
                missingTimeValueInput.value = ''; 
                missingTimeValueInput.classList.remove('input-error'); 
                missingTimeError.style.display = 'none'; 
                missingTimeError.textContent = '';
                singleCorrectionActionSelect.classList.remove('input-error'); 
                singleCorrectionActionError.style.display = 'none';
                
                if (action === "isEntry_addExit") { 
                    missingTimeLabel.textContent = "Orario Uscita Mancante (HH:MM):"; 
                    missingTimeFieldGroup.style.display = 'block'; 
                } else if (action === "isExit_addEntry") { 
                    missingTimeLabel.textContent = "Orario Entrata Mancante (HH:MM):"; 
                    missingTimeFieldGroup.style.display = 'block'; 
                } else { 
                    missingTimeFieldGroup.style.display = 'none'; 
                }
                updateMissingTimeDateContext(); 
                updateMainButtonState(); 
            }

            function validateForm() {
            let isValid = true;
            // Reset messaggi di errore e classi
            if (missingTimeError) { missingTimeError.style.display = 'none'; missingTimeError.textContent = ''; }
            if (missingTimeValueInput) missingTimeValueInput.classList.remove('input-error');
            if (singleCorrectionActionSelect) singleCorrectionActionSelect.classList.remove('input-error');
            if (singleCorrectionActionError) { singleCorrectionActionError.style.display = 'none'; singleCorrectionActionError.textContent = ''; }

            // Controlla solo la sezione di correzione timbratura singola se è visibile
            if (singleTimeCorrectionSection.style.display !== 'none') {
                const action = singleCorrectionActionSelect.value;
                const missingTimeStr = missingTimeValueInput.value;
                
                // Recupera i dati originali
                const originalWorkDayISO = originalProblemDateISOInput.value; // Giorno LAVORATIVO originale
                const originalTimeStr = originalSingleTimeInput.value;       // Ora originale (HH:MM)
                
                // Recupera la data SOLARE effettiva della timbratura originale (calcolata da populateUI)
                const actualOriginalSolarDateISO = document.getElementById('effectiveOriginalSolarDateISOInput').value;
                
                // Recupera la data SOLARE inferita per la timbratura MANCANTE (calcolata da updateMissingTimeDateContext)
                const inferredDateForMissingPairISO = missingTimeDateContext.dataset.inferredMissingPairDate || originalWorkDayISO;

                if (action === '') {
                    if (singleCorrectionActionError) { singleCorrectionActionError.textContent = "Selezionare un'azione."; singleCorrectionActionError.style.display = 'block'; }
                    if (singleCorrectionActionSelect) singleCorrectionActionSelect.classList.add('input-error');
                    isValid = false;
                } else {
                    if (!missingTimeStr) {
                        if (missingTimeError) { missingTimeError.textContent = "Orario obbligatorio."; missingTimeError.style.display = 'block'; }
                        if (missingTimeValueInput) missingTimeValueInput.classList.add('input-error');
                        isValid = false;
                    } else if (!isValidTimeFormat(missingTimeStr)) {
                        if (missingTimeError) { missingTimeError.textContent = "Formato ora (HH:MM) non valido."; missingTimeError.style.display = 'block'; }
                        if (missingTimeValueInput) missingTimeValueInput.classList.add('input-error');
                        isValid = false;
                    } else if (!isValidTimeFormat(originalTimeStr) || !originalWorkDayISO || !actualOriginalSolarDateISO) {
                        // Se uno di questi dati cruciali manca, la validazione non può essere completa.
                        console.warn("validateForm: Dati originali (ora, giorno lavorativo o data solare effettiva) non completi per validazione.");
                        if (missingTimeError) { 
                            missingTimeError.textContent = "Dati del problema originale incompleti. Impossibile validare."; 
                            missingTimeError.style.display = 'block'; 
                        }
                        isValid = false; 
                    } else {
                        // Se tutti i dati base ci sono, procedi con la validazione logica
                        let originalDateTime, missingPairDateTime;
                        let entryDateTime, exitDateTime;

                        try {
                            // Crea oggetti Date interpretandoli come UTC (aggiungendo 'Z')
                            // originalDateTime è la timbratura ESISTENTE
                            originalDateTime = new Date(`${actualOriginalSolarDateISO}T${originalTimeStr}:00Z`);
                            // missingPairDateTime è la timbratura che l'UTENTE STA AGGIUNGENDO
                            missingPairDateTime = new Date(`${inferredDateForMissingPairISO}T${missingTimeStr}:00Z`);

                            if (isNaN(originalDateTime.getTime()) || isNaN(missingPairDateTime.getTime())) {
                                throw new Error("Data/ora non valide per la creazione dell'oggetto Date per il confronto.");
                            }

                            if (action === "isEntry_addExit") { 
                                // Timbratura esistente (originalDateTime) è l'ENTRATA
                                // Timbratura da aggiungere (missingPairDateTime) è l'USCITA
                                entryDateTime = originalDateTime;
                                exitDateTime = missingPairDateTime;
                                if (exitDateTime.getTime() <= entryDateTime.getTime()) {
                                    if (missingTimeError) { missingTimeError.textContent = `L'uscita (${missingTimeStr} del ${formatDate_DDMMYYYY(inferredDateForMissingPairISO)}) deve essere successiva all'entrata (${originalTimeStr} del ${formatDate_DDMMYYYY(actualOriginalSolarDateISO)}).`; missingTimeError.style.display = 'block'; }
                                    if (missingTimeValueInput) missingTimeValueInput.classList.add('input-error');
                                    isValid = false;
                                }
                            } else if (action === "isExit_addEntry") {
                                // Timbratura esistente (originalDateTime) è l'USCITA
                                // Timbratura da aggiungere (missingPairDateTime) è l'ENTRATA
                                entryDateTime = missingPairDateTime;
                                exitDateTime = originalDateTime;
                                if (entryDateTime.getTime() >= exitDateTime.getTime()) {
                                    if (missingTimeError) { missingTimeError.textContent = `L'entrata (${missingTimeStr} del ${formatDate_DDMMYYYY(inferredDateForMissingPairISO)}) deve essere precedente all'uscita (${originalTimeStr} del ${formatDate_DDMMYYYY(actualOriginalSolarDateISO)}).`; missingTimeError.style.display = 'block'; }
                                    if (missingTimeValueInput) missingTimeValueInput.classList.add('input-error');
                                    isValid = false;
                                }
                            }

                            // CONTROLLO GENERALE SULLA DURATA MASSIMA DEL TURNO (se la validazione di base è passata finora)
                            if (isValid && entryDateTime && exitDateTime) {
                                const durationMillis = exitDateTime.getTime() - entryDateTime.getTime();
                                const durationHours = durationMillis / (1000 * 60 * 60);

                                if (durationHours > 16) {
                                    if (missingTimeError) {
                                        missingTimeError.textContent = `La durata del turno (${durationHours.toFixed(1)} ore) supera il limite di 16 ore. Controllare date/orari.`;
                                        missingTimeError.style.display = 'block';
                                    }
                                    if (missingTimeValueInput) missingTimeValueInput.classList.add('input-error');
                                    isValid = false;
                                } else if (durationHours <= 0 && (action === "isEntry_addExit" || action === "isExit_addEntry")) {
                                    // Questo controllo è importante per durate zero o negative non catturate prima
                                    if (missingTimeError && missingTimeError.style.display === 'none') { // Mostra solo se non c'è già un errore più specifico
                                        missingTimeError.textContent = `La durata del turno (${durationHours.toFixed(1)}h) non può essere zero o negativa. Controllare date/orari.`;
                                        missingTimeError.style.display = 'block';
                                    }
                                    if (missingTimeValueInput && !missingTimeValueInput.classList.contains('input-error')) missingTimeValueInput.classList.add('input-error');
                                    isValid = false;
                                }
                            }

                        } catch (e) {
                            console.error("Errore nella creazione/comparazione date per validazione:", e);
                            if (missingTimeError) { missingTimeError.textContent = "Errore interno nella validazione date/orari. " + e.message; missingTimeError.style.display = 'block'; }
                            isValid = false;
                        }
                    }
                }
            }
            // Non ci sono altri campi da validare al momento (es. 'correctedDate' o le note sono opzionali)
            return isValid;
        }

            function updateMainButtonState() {
                if (!tg || !tg.MainButton) return;
                const formIsValid = validateForm(); 
                if (formIsValid) {
                    tg.MainButton.setParams({
                        is_active: true,
                        color: tg.themeParams.button_color || '#2481CC',
                        text_color: tg.themeParams.button_text_color || '#FFFFFF',
                    });
                    tg.MainButton.enable();
                    tg.MainButton.show(); 
                } else {
                    tg.MainButton.disable(); 
                    tg.MainButton.hide();   
                }
            }
            
            function handleFormSubmit() {
                if (!validateForm()) { 
                    tg.showAlert("Correggi gli errori nel form.", function() { 
                        const firstErrorInput = document.querySelector('#correctionForm .input-error'); 
                        if (firstErrorInput) firstErrorInput.focus();
                    }); 
                    return; 
                }

                tg.showConfirm("Confermi l'invio della correzione?", function(isConfirmed) {
                    if (isConfirmed) {
                        if (tg.HapticFeedback) tg.HapticFeedback.impactOccurred('light');
                        
                        tg.MainButton.showProgress();
                        tg.MainButton.disable(); 
                        
                        const inferredMissingPairDate = missingTimeDateContext.dataset.inferredMissingPairDate || originalProblemDateISOInput.value;
                        
                        const dataToSend = {
                            problemContextId: problemContextIdInput.value,
                            originalEmployeeName: originalEmployeeNameInput.value,
                            originalProblemDateISO: originalProblemDateISOInput.value,
                            originalSingleTime: originalSingleTimeInput.value,
                            originalSingleBar: originalSingleBarInput.value,
                            singleCorrectionAction: singleCorrectionActionSelect.value,
                            missingTimeValue: missingTimeValueInput.value,
                            correctedDate: singleTimeCorrectionSection.style.display !== 'none' ? inferredMissingPairDate : correctedDateInput.value,
                            notes: notesTextField ? notesTextField.textContent.trim() : "", // Legge dal nuovo campo note
                            initDataRaw: tg.initData || "",
                            telegramUserId: currentUserDetails.id,
                            correctorUserInfo: currentUserDetails,
                            clientTimestamp: new Date().toISOString(),
                            startParamReceived: startParamValueForDebug
                        };
                        console.log("Invio a GAS:", JSON.stringify(dataToSend, null, 2));
                        console.log("MINI-APP DEBUG: Invio questo payload al server:", JSON.stringify(dataToSend, null, 2));
                        tg.showAlert("DEBUG: Sto per inviare: " + dataToSend.problemContextId); // Un alert per essere sicuri

                        fetch(GAS_WEB_APP_URL, { method: 'POST', redirect: 'follow', cache: 'no-cache', headers: { 'Content-Type': 'text/plain;charset=utf-8' }, body: JSON.stringify({ payload: dataToSend }) })
                        .then(response => { 
                            if (!response.ok) { 
                                return response.text().then(text => { 
                                    try { const errData = JSON.parse(text); throw new Error(errData.message || `Errore HTTP ${response.status} - ${text.substring(0,100)}`); } 
                                    catch (parseError) { throw new Error(`Errore HTTP ${response.status} - Risposta non JSON: ${text.substring(0,100)}`); }
                                }); 
                            } 
                            return response.json(); 
                        })
                        .then(data => { 
                            console.log('GAS OK:', data); 
                            if (data.status === "successo") { 
                                if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('success');
                                tg.MainButton.setText("INVIATO!"); 
                                tg.showAlert(data.message || "Correzione inviata!", function() { tg.close(); }); 
                            } else { 
                                if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('error');
                                tg.MainButton.hideProgress(); 
                                updateMainButtonState(); 
                                tg.showAlert(`Errore App: ${data.message || 'Sconosciuto.'}`); 
                            }
                        })
                        .catch((error) => { 
                            if (tg.HapticFeedback) tg.HapticFeedback.notificationOccurred('error');
                            console.error('Errore Fetch GAS:', error); 
                            tg.MainButton.hideProgress();
                            updateMainButtonState();
                            tg.showAlert(`Errore Comunicazione: ${error.message}.`); 
                        });
                    }
                });
            }

            // Funzioni del vecchio sistema di note rimosse:
            // openNotesModal, closeNotesModal, saveNotesFromModal

            try {
                console.log("Avvio Inizializzazione Mini App...");
                if (!tg) { showFatalError("Oggetto Telegram.WebApp non definito."); return; }
                
                tg.onEvent('themeChanged', () => {
                    setThemeClass();
                    applyThemeVariables(); 
                    updateMainButtonState(); 
                });
                setThemeClass(); 
                tg.ready(); 
                applyThemeVariables(); 
                tg.expand();

                if (tg.MainButton) {
                    tg.MainButton.setText("INVIA CORREZIONE");
                    tg.MainButton.onClick(handleFormSubmit);
                } else {
                    console.warn("Telegram.WebApp.MainButton non disponibile.");
                }

                if (tg.BackButton) { tg.BackButton.show(); tg.BackButton.onClick(function() { tg.showConfirm("Chiudere senza salvare?", (ok) => { if(ok) tg.close(); }); }); }
                
                if (tg.initDataUnsafe && tg.initDataUnsafe.user) {
                     currentUserDetails.id = String(tg.initDataUnsafe.user.id); 
                     currentUserDetails.username = tg.initDataUnsafe.user.username || "";
                     currentUserDetails.first_name = tg.initDataUnsafe.user.first_name || "";
                     currentUserDetails.last_name = tg.initDataUnsafe.user.last_name || "";
                } else { console.warn("Dati utente (tg.initDataUnsafe.user) non trovati."); }

                if(tg.initDataUnsafe && tg.initDataUnsafe.start_param){ startParamValueForDebug = tg.initDataUnsafe.start_param; } 
                else { 
                    const urlParams = new URLSearchParams(window.location.search); 
                    const webAppStartParam = urlParams.get('tgWebAppStartParam'); 
                    if(webAppStartParam) startParamValueForDebug = webAppStartParam; 
                }
                
                console.log("startParam letto:", startParamValueForDebug);

                if (startParamValueForDebug && startParamValueForDebug !== "Nessuno (non letto)") {
                    const parsedData = parseStartParam(startParamValueForDebug);
                    populateUI(parsedData); 
                } else {
                    showFatalError("Parametro di avvio (start_param) non trovato o non valido.", startParamValueForDebug, null, tg.initData, tg.initDataUnsafe, window.location.search);
                    return;
                }
                
                const DEBUG_USER_ID = 'IL_TUO_ID_TELEGRAM_PER_DEBUG'; 
                if (isDebugMode || (currentUserDetails.id && currentUserDetails.id === DEBUG_USER_ID)) { 
                    if(debugSection) debugSection.style.display = 'block';
                }

                if (notesTextField) {
                    notesTextField.addEventListener('keydown', function(event) {
                        // Se viene premuto Enter e NON Shift+Enter
                        if (event.key === 'Enter' && !event.shiftKey) {
                            event.preventDefault(); // Impedisce di andare a capo
                            handleFormSubmit();     // Chiama la funzione di invio del form
                        }
                        // Se si vuole permettere Shift+Enter per andare a capo, non serve altro qui.
                        // Se si vuole bloccare anche Shift+Enter, la condizione sarebbe solo: if (event.key === 'Enter')
                    });

                    // Listener per focus e blur (già presenti, li lascio per contesto)
                    notesTextField.addEventListener('focus', function() {
                        if (this.textContent === this.dataset.placeholder) {
                            // this.textContent = ''; // Opzionale, il CSS dovrebbe gestirlo
                        }
                    });
                    notesTextField.addEventListener('blur', function() {
                        if (this.textContent.trim() === '') {
                            this.innerHTML = ''; 
                        }
                    });
                }


                
                if (singleCorrectionActionSelect) {
                    singleCorrectionActionSelect.addEventListener('change', handleSingleCorrectionActionChange); 
                }
                if (missingTimeValueInput) {
                    missingTimeValueInput.addEventListener('input', function() { 
                        if(missingTimeError) { missingTimeError.style.display = 'none'; missingTimeError.textContent = ''; }
                        missingTimeValueInput.classList.remove('input-error'); 
                        updateMissingTimeDateContext(); 
                        updateMainButtonState(); 
                    });
                    missingTimeValueInput.addEventListener('blur', function() { 
                        updateMainButtonState(); 
                    }); 
                }
                
                updateMainButtonState(); 

                console.log("Inizializzazione Mini App completata.");

            } catch (initError) {
                console.error("Errore CRITICO Inizializzazione:", initError, initError.stack);
                showFatalError(initError.message + (initError.stack ? ` Stack: ${initError.stack.substring(0,250)}...` : ""), startParamValueForDebug, null, tg.initData, tg.initDataUnsafe, window.location.search);
            }
        });
    </script>
</body>
</html>